module FixedOutputs where

data FoSource = FoSrcDerivations | FoSrcTarballs DryRun [Print]
  deriving (Eq, Show)

data Print
  = PrintDrv
  | PrintHash | PrintMode | PrintName | PrintPath | PrintHashType | PrintUrls
  deriving (Eq, Show)

-- fixed output tarballs mirror command
run hc
  (Opts basePath useConduit
   (FixedOutputs foJsonFile (FoSrcTarballs isDry prints : foSrcs) : cmds)) =
  let foPath = basePath ++ "/tarballs"
  in do
    createDirectoryIfMissing True foPath
    fixedOutputsInfos <- decodeFixedOutputsJsonFile foJsonFile
    putStrLn
      ("starting fixed output tarballs download for \"" ++ foJsonFile ++ "\"")
    runReaderT
      (dlFoTbs isDry prints fixedOutputsInfos)
      (DownloadAppConfig foPath useConduit)
    putStrLn
      ("finished fixed output tarballs download for \"" ++ foJsonFile ++ "\"")
    -- work on the rest of the fixed output sources (kinds)
    run hc (Opts basePath useConduit
            (FixedOutputs foJsonFile foSrcs : cmds))
-- fixed output derivations mirror command
run hc (Opts basePath useConduit (FixedOutputs _ [] : cmds)) =
  -- work on the rest of the commands
  run hc (Opts basePath useConduit cmds)

-- | Download fixed output tarballs with logging (printing).
dlFoTbs :: (MonadReader DownloadAppConfig m, MonadIO m)
        => Bool -> [Print] -> [FixedOutputInfo] -> m ()
dlFoTbs isDry prints = mapM_ dlTbWithLog
  where
    dlTbWithLog foi = do
      liftIO $ putStr "[downloading] " >> printFixedOutputInfo prints foi
      unless isDry
        $ downloadFixedOutputTarball foi >>= liftIO . putStrLn . log' foi
    showErrors = ("\n---\n" ++) . L.intercalate "\n---\n" . map show
    log' _ (Nothing, []) =
      error "internal error: no file downloaded and no error"
    log' _ (Just fp, es) = "[saved] \"" ++ fp ++ "\"\n" ++
                           "while having some errors:\n" ++ showErrors es
    log' foi (Nothing, es) =
      "[error] could not download tarball for: " ++ T.unpack (_path foi)
      ++ showErrors es ++ "\n\n"

fixedOutputsCmd :: Mod CommandFields Command
fixedOutputsCmd = command "fixedOutputs"
  $ info (inputInfo <*> fixedOutputsOpts)
  $ progDesc "Download Nix fixed outputs given json array of derivations info."
  where
    inputInfo = infoOption foInputInfoMsg
      (long "input-help"
        <> help "Instructions for obtaining \
                \fixed output derivations json input file." )

fixedOutputsOpts :: Parser Command
fixedOutputsOpts = FixedOutputs <$>
  strOption
  (long "drvs-json" <> metavar "DRVS_JSON_FILE"
   <> help "Path to a json file produced with find-fixed-outputs.nix.")
  <*>
  some
  (
    flag' FoSrcDerivations
    (long "derivations"
     <> help "Download fixed output derivations (from cache.nixos.org), \
             \targeting at /nix/store/.")
    <|>
    flag' FoSrcTarballs
    (long "tarballs"
     <> help "Download the \"tarballs\" of fixed output derivations, \
             \building up a mirror of tarballs.nixos.org.")
    <*>
    switch
    (long "dry-run"
     <> help "Do not actually download. Useful in combination with --print-*.")
    <*>
    many prints
  )
  where
    prints =
      flag' PrintDrv
      (long "print-drv"       <> help "Print `drv` path (/nix/store/*.drv).")
      <|>
      flag' PrintHash
      (long "print-hash"      <> help "Print hashes.")
      <|>
      flag' PrintMode
      (long "print-mode"      <> help "Print mode: `flat` or `recursive`.")
      <|>
      flag' PrintName
      (long "print-name"      <> help "Print name of derivations.")
      <|>
      flag' PrintPath
      (long "print-path"      <> help "Print store path (/nix/store/*).")
      <|>
      flag' PrintHashType
      (long "print-hash-type" <> help "Print hash type, e.g. `sha1`.")
      <|>
      flag' PrintUrls
      (long "print-urls"      <> help "Print original source urls.")

foInputInfoMsg :: String
foInputInfoMsg =
  "1. Get `find-fixed-outputs.nix` script from `nix-mirror` git repository.\n\
  \2. Determine and set NIX_PATH $nixpkgs value for the derired commit.\n\
  \3. Use this command to produce the json file:\n\
  \$ nix-instantiate -I nixpkgs=$nixpkgs --eval --strict --json find-fixed-outputs.nix --arg expr 'import <nixpkgs/maintainers/scripts/all-tarballs.nix>' > nixpkgs-fixed-outputs.json\n\
  \\n\
  \Warning! This action needs approximately 8 GiB of RAM as of 2019-09."

-- | Print selected fields of a fixed output derivation.
printFixedOutputInfo :: [Print] -> FixedOutputInfo -> IO ()
printFixedOutputInfo ps (FixedOutputInfo drv hash mode name path type' urls) =
  let showAssoc =
        [ (PrintDrv,      "drv: "  ++ T.unpack drv)
        , (PrintHash,     "hash: " ++ T.unpack hash)
        , (PrintMode,     "mode: " ++ show mode)
        , (PrintName,     "name: " ++ T.unpack name)
        , (PrintPath,     "path: " ++ T.unpack path)
        , (PrintHashType, "type: " ++ show type')
        , (PrintUrls,     "urls: " ++ show urls)
        ]
  in putStrLn $ L.intercalate "; " $ mapMaybe (`lookup` showAssoc) ps
